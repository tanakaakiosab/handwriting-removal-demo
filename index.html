<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>é«˜ç²¾åº¦æ‰‹æ›¸ãæ–‡å­—æ¶ˆå»ãƒ„ãƒ¼ãƒ«</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    .container {
      background: white;
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 2.2em;
    }
    .upload-section {
      text-align: center;
      margin-bottom: 30px;
    }
    .file-input-wrapper {
      position: relative;
      display: inline-block;
      cursor: pointer;
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      padding: 15px 30px;
      border-radius: 25px;
      transition: all 0.3s ease;
      font-size: 16px;
      font-weight: 500;
    }
    .file-input-wrapper:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #fileInput {
      position: absolute;
      left: -9999px;
    }
    .controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .control-group label {
      font-weight: 500;
      color: #555;
      font-size: 14px;
    }
    input[type="range"] {
      width: 120px;
      -webkit-appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #ddd;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #667eea;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }
    .canvas-container {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin: 30px 0;
      flex-wrap: wrap;
    }
    .canvas-wrapper {
      text-align: center;
    }
    .canvas-wrapper h3 {
      margin-bottom: 15px;
      color: #555;
      font-size: 1.1em;
    }
    canvas {
      border: 2px solid #ddd;
      border-radius: 10px;
      max-width: 500px;
      max-height: 400px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
    }
    canvas:hover {
      transform: scale(1.02);
    }
    .buttons {
      text-align: center;
      margin: 30px 0;
      display: flex;
      gap: 15px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .btn {
      padding: 12px 25px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
    }
    .btn-primary {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
    }
    .btn-success {
      background: linear-gradient(45deg, #56ab2f, #a8e6cf);
      color: white;
    }
    .btn-warning {
      background: linear-gradient(45deg, #f093fb, #f5576c);
      color: white;
    }
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    #status {
      text-align: center;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    .status-ready { background: #d4edda; color: #155724; }
    .status-processing { background: #fff3cd; color: #856404; }
    .status-success { background: #d1ecf1; color: #0c5460; }
    .status-error { background: #f8d7da; color: #721c24; }
    .progress-container {
      width: 100%;
      background: #f0f0f0;
      border-radius: 10px;
      margin: 15px 0;
      overflow: hidden;
      display: none;
    }
    .progress-bar {
      height: 8px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      border-radius: 10px;
      transition: width 0.3s ease;
      width: 0%;
    }
    .stats {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      margin-top: 20px;
      display: none;
    }
    .stats h3 {
      margin-top: 0;
      color: #333;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    .stat-item {
      background: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .stat-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #667eea;
    }
    .stat-label {
      font-size: 0.9em;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¯ é«˜ç²¾åº¦æ‰‹æ›¸ãæ–‡å­—æ¶ˆå»ãƒ„ãƒ¼ãƒ«</h1>
    
    <div class="upload-section">
      <div class="file-input-wrapper">
        <input type="file" id="fileInput" accept="image/*">
        ğŸ“ ç”»åƒã‚’é¸æŠ
      </div>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>æ„Ÿåº¦èª¿æ•´</label>
        <input type="range" id="sensitivitySlider" min="0" max="20" value="8" step="1">
        <span id="sensitivityValue">8</span>
      </div>
      <div class="control-group">
        <label>ãƒã‚¤ã‚ºé™¤å»</label>
        <input type="range" id="noiseSlider" min="1" max="7" value="3" step="2">
        <span id="noiseValue">3</span>
      </div>
      <div class="control-group">
        <label>æœ€å°æ–‡å­—ã‚µã‚¤ã‚º</label>
        <input type="range" id="minSizeSlider" min="5" max="50" value="15" step="5">
        <span id="minSizeValue">15</span>
      </div>
      <div class="control-group">
        <label>æœ€å¤§æ–‡å­—ã‚µã‚¤ã‚º</label>
        <input type="range" id="maxSizeSlider" min="1000" max="50000" value="25000" step="1000">
        <span id="maxSizeValue">25000</span>
      </div>
    </div>

    <div class="buttons">
      <button class="btn btn-primary" id="autoProcessBtn" disabled>ğŸ¤– è‡ªå‹•æœ€é©åŒ–å‡¦ç†</button>
      <button class="btn btn-warning" id="manualProcessBtn" disabled>âš™ï¸ æ‰‹å‹•è¨­å®šã§å‡¦ç†</button>
      <button class="btn btn-success" id="resetBtn" disabled>ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar" id="progressBar"></div>
    </div>

    <p id="status" class="status-ready">OpenCV.js ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>

    <div class="canvas-container">
      <div class="canvas-wrapper">
        <h3>å…ƒç”»åƒ</h3>
        <canvas id="originalCanvas"></canvas>
      </div>
      <div class="canvas-wrapper">
        <h3>å‡¦ç†çµæœ</h3>
        <canvas id="resultCanvas"></canvas>
      </div>
    </div>

    <div class="buttons">
      <a id="downloadLink" href="#" download="cleaned-image.png" class="btn btn-success" style="display:none;">ğŸ’¾ å‡¦ç†ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a>
    </div>

    <div class="stats" id="statsPanel">
      <h3>ğŸ“Š å‡¦ç†çµæœçµ±è¨ˆ</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="removedCount">-</div>
          <div class="stat-label">å‰Šé™¤ã—ãŸæ–‡å­—æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="totalArea">-</div>
          <div class="stat-label">å‰Šé™¤é¢ç© (pxÂ²)</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="optimalC">-</div>
          <div class="stat-label">æœ€é©Cå€¤</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="processingTime">-</div>
          <div class="stat-label">å‡¦ç†æ™‚é–“ (ç§’)</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let originalImage = null;
    let isProcessing = false;

    function onOpenCvReady() {
      updateStatus("æº–å‚™å®Œäº†ï¼ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„", "ready");
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
      document.getElementById("fileInput").addEventListener("change", handleFileSelect);
      document.getElementById("autoProcessBtn").addEventListener("click", autoProcess);
      document.getElementById("manualProcessBtn").addEventListener("click", manualProcess);
      document.getElementById("resetBtn").addEventListener("click", resetAll);
      
      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤è¡¨ç¤ºæ›´æ–°
      setupSliders();
    }

    function setupSliders() {
      const sliders = [
        { id: 'sensitivitySlider', valueId: 'sensitivityValue' },
        { id: 'noiseSlider', valueId: 'noiseValue' },
        { id: 'minSizeSlider', valueId: 'minSizeValue' },
        { id: 'maxSizeSlider', valueId: 'maxSizeValue' }
      ];

      sliders.forEach(slider => {
        const element = document.getElementById(slider.id);
        document.getElementById(slider.valueId).textContent = element.value;
        element.addEventListener('input', (e) => {
          document.getElementById(slider.valueId).textContent = e.target.value;
          if (originalImage && !isProcessing) {
            debounceManualProcess();
          }
        });
      });
    }

    let debounceTimer;
    function debounceManualProcess() {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(manualProcess, 500);
    }

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.onload = () => {
        originalImage = img;
        displayOriginalImage(img);
        enableButtons();
        updateStatus("ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸã€‚å‡¦ç†æ–¹æ³•ã‚’é¸æŠã—ã¦ãã ã•ã„", "success");
      };
      img.src = URL.createObjectURL(file);
    }

    function displayOriginalImage(img) {
      const canvas = document.getElementById("originalCanvas");
      const maxSize = 500;
      const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
      
      canvas.width = img.width * scale;
      canvas.height = img.height * scale;
      
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    }

    function enableButtons() {
      document.getElementById("autoProcessBtn").disabled = false;
      document.getElementById("manualProcessBtn").disabled = false;
      document.getElementById("resetBtn").disabled = false;
    }

    function updateStatus(message, type = "ready") {
      const status = document.getElementById("status");
      status.textContent = message;
      status.className = `status-${type}`;
    }

    function showProgress(show = true) {
      const container = document.getElementById("progressContainer");
      container.style.display = show ? "block" : "none";
      if (!show) {
        document.getElementById("progressBar").style.width = "0%";
      }
    }

    function updateProgress(percent) {
      document.getElementById("progressBar").style.width = `${percent}%`;
    }

    async function autoProcess() {
      if (isProcessing || !originalImage) return;
      
      isProcessing = true;
      const startTime = Date.now();
      
      updateStatus("è‡ªå‹•æœ€é©åŒ–å‡¦ç†ä¸­...", "processing");
      showProgress(true);
      
      try {
        const result = await findOptimalParameters(originalImage);
        updateProgress(100);
        
        const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
        updateStats(result.removedCount, result.totalArea, result.optimalC, processingTime);
        
        updateStatus(`å‡¦ç†å®Œäº†ï¼æœ€é©Cå€¤: ${result.optimalC}`, "success");
        document.getElementById("statsPanel").style.display = "block";
        
      } catch (error) {
        console.error("å‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
        updateStatus("å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", "error");
      } finally {
        isProcessing = false;
        showProgress(false);
      }
    }

    async function findOptimalParameters(img) {
      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);
      
      const srcBase = cv.imread(canvas);
      const candidates = [];
      
      // ã‚ˆã‚Šè©³ç´°ãªç¯„å›²ã§ãƒ†ã‚¹ãƒˆ
      for (let c = 0; c <= 25; c++) {
        updateProgress((c / 25) * 80);
        
        const result = analyzeWithC(srcBase, c);
        candidates.push(result);
        
        // å°‘ã—å¾…æ©Ÿã—ã¦UIã®æ›´æ–°ã‚’è¨±å¯
        if (c % 5 === 0) {
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      
      // æœ€é©ãªCå€¤ã‚’é¸æŠï¼ˆé¢ç©ã¨æ•°ã®ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ï¼‰
      const best = candidates.reduce((a, b) => {
        const scoreA = a.area + a.count * 50; // æ–‡å­—æ•°ã‚‚é‡è¦–
        const scoreB = b.area + b.count * 50;
        return scoreA > scoreB ? a : b;
      });
      
      updateProgress(90);
      
      // æœ€é©ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§æœ€çµ‚å‡¦ç†
      const finalResult = processImage(srcBase, best.cVal);
      
      srcBase.delete();
      return finalResult;
    }

    function analyzeWithC(srcBase, c) {
      const src = srcBase.clone();
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      
      // ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ å‡ç­‰åŒ–ã§ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆå‘ä¸Š
      cv.equalizeHist(gray, gray);
      
      const blur = new cv.Mat();
      cv.GaussianBlur(gray, blur, new cv.Size(3, 3), 0);
      
      const binary = new cv.Mat();
      cv.adaptiveThreshold(blur, binary, 255,
        cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, c);
      
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      
      let totalArea = 0;
      let validCount = 0;
      
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        if (isValidHandwriting(cnt)) {
          totalArea += cv.contourArea(cnt);
          validCount++;
        }
        cnt.delete();
      }
      
      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      src.delete();
      gray.delete();
      blur.delete();
      binary.delete();
      contours.delete();
      hierarchy.delete();
      
      return { cVal: c, area: totalArea, count: validCount };
    }

    function isValidHandwriting(contour) {
      const area = cv.contourArea(contour);
      const rect = cv.boundingRect(contour);
      const aspect = rect.width / rect.height;
      const perimeter = cv.arcLength(contour, true);
      
      // ã‚ˆã‚Šå³å¯†ãªæ¡ä»¶
      const minSize = parseInt(document.getElementById("minSizeSlider").value);
      const maxSize = parseInt(document.getElementById("maxSizeSlider").value);
      
      // å††å½¢åº¦ã®è¨ˆç®—ï¼ˆ4Ï€A/PÂ²ï¼‰
      const circularity = (4 * Math.PI * area) / (perimeter * perimeter);
      
      // å……å®Ÿåº¦ã®è¨ˆç®—
      const hullArea = cv.contourArea(cv.convexHull(contour, new cv.Mat(), false, true));
      const solidity = area / hullArea;
      
      return (
        area >= minSize && area <= maxSize &&
        aspect >= 0.1 && aspect <= 10.0 &&
        circularity < 0.85 && // å®Œå…¨ãªå††ã¯é™¤å¤–
        solidity > 0.3 && // å‡¹ã¿ã™ãã‚‹å½¢çŠ¶ã¯é™¤å¤–
        rect.width >= 3 && rect.height >= 3 // æœ€å°ã‚µã‚¤ã‚º
      );
    }

    function manualProcess() {
      if (isProcessing || !originalImage) return;
      
      isProcessing = true;
      const startTime = Date.now();
      
      updateStatus("æ‰‹å‹•è¨­å®šã§å‡¦ç†ä¸­...", "processing");
      
      try {
        const canvas = document.createElement("canvas");
        canvas.width = originalImage.width;
        canvas.height = originalImage.height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(originalImage, 0, 0);
        
        const src = cv.imread(canvas);
        const cValue = parseInt(document.getElementById("sensitivitySlider").value);
        const result = processImage(src, cValue);
        
        const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);
        updateStats(result.removedCount, result.totalArea, cValue, processingTime);
        
        updateStatus(`æ‰‹å‹•å‡¦ç†å®Œäº†ï¼Cå€¤: ${cValue}`, "success");
        document.getElementById("statsPanel").style.display = "block";
        
        src.delete();
        
      } catch (error) {
        console.error("å‡¦ç†ã‚¨ãƒ©ãƒ¼:", error);
        updateStatus("å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ", "error");
      } finally {
        isProcessing = false;
      }
    }

    function processImage(src, cValue) {
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.equalizeHist(gray, gray);
      
      const noiseKernel = parseInt(document.getElementById("noiseSlider").value);
      const blur = new cv.Mat();
      cv.GaussianBlur(gray, blur, new cv.Size(noiseKernel, noiseKernel), 0);
      
      const binary = new cv.Mat();
      cv.adaptiveThreshold(blur, binary, 255,
        cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, cValue);
      
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      
      // èƒŒæ™¯è‰²ã®æ¨å®šï¼ˆè¤‡æ•°ã‚¨ãƒªã‚¢ã‹ã‚‰ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ï¼‰
      const bgColor = estimateBackgroundColor(src);
      
      let removedCount = 0;
      let totalArea = 0;
      
      for (let i = 0; i < contours.size(); i++) {
        const cnt = contours.get(i);
        if (isValidHandwriting(cnt)) {
          const area = cv.contourArea(cnt);
          totalArea += area;
          removedCount++;
          
          // ã‚ˆã‚Šè‡ªç„¶ãªå¡—ã‚Šã¤ã¶ã—ã®ãŸã‚ã€è†¨å¼µå‡¦ç†
          const mask = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
          cv.drawContours(mask, contours, i, new cv.Scalar(255), -1);
          
          // è»½å¾®ãªè†¨å¼µã§å¢ƒç•Œã‚’æ»‘ã‚‰ã‹ã«
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
          cv.dilate(mask, mask, kernel);
          
          const color = new cv.Scalar(bgColor[0], bgColor[1], bgColor[2], 255);
          src.setTo(color, mask);
          
          mask.delete();
          kernel.delete();
        }
        cnt.delete();
      }
      
      displayResult(src);
      
      // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      gray.delete();
      blur.delete();
      binary.delete();
      contours.delete();
      hierarchy.delete();
      
      return { removedCount, totalArea, optimalC: cValue };
    }

    function estimateBackgroundColor(src) {
      // å››éš…ã‹ã‚‰èƒŒæ™¯è‰²ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      const samples = [
        src.roi(new cv.Rect(0, 0, 20, 20)),
        src.roi(new cv.Rect(src.cols - 20, 0, 20, 20)),
        src.roi(new cv.Rect(0, src.rows - 20, 20, 20)),
        src.roi(new cv.Rect(src.cols - 20, src.rows - 20, 20, 20))
      ];
      
      let totalR = 0, totalG = 0, totalB = 0;
      for (const sample of samples) {
        const mean = cv.mean(sample);
        totalR += mean[0];
        totalG += mean[1];
        totalB += mean[2];
        sample.delete();
      }
      
      return [totalR / 4, totalG / 4, totalB / 4];
    }

    function displayResult(processedMat) {
      const canvas = document.getElementById("resultCanvas");
      const originalCanvas = document.getElementById("originalCanvas");
      
      canvas.width = originalCanvas.width;
      canvas.height = originalCanvas.height;
      
      // çµæœã‚’è¡¨ç¤ºç”¨ã«ãƒªã‚µã‚¤ã‚º
      const resized = new cv.Mat();
      cv.resize(processedMat, resized, new cv.Size(canvas.width, canvas.height));
      cv.imshow("resultCanvas", resized);
      
      // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’è¨­å®šï¼ˆå…ƒè§£åƒåº¦ï¼‰
      const fullCanvas = document.createElement("canvas");
      fullCanvas.width = processedMat.cols;
      fullCanvas.height = processedMat.rows;
      cv.imshow(fullCanvas, processedMat);
      
      const link = document.getElementById("downloadLink");
      link.href = fullCanvas.toDataURL("image/png");
      link.style.display = "inline-block";
      
      resized.delete();
    }

    function updateStats(removedCount, totalArea, optimalC, processingTime) {
      document.getElementById("removedCount").textContent = removedCount;
      document.getElementById("totalArea").textContent = Math.round(totalArea).toLocaleString();
      document.getElementById("optimalC").textContent = optimalC;
      document.getElementById("processingTime").textContent = processingTime;
    }

    function resetAll() {
      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
      const canvases = ["originalCanvas", "resultCanvas"];
      canvases.forEach(id => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        canvas.width = canvas.height = 0;
      });
      
      // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      originalImage = null;
      isProcessing = false;
      
      // UIã‚’ãƒªã‚»ãƒƒãƒˆ
      document.getElementById("fileInput").value = "";
      document.getElementById("downloadLink").style.display = "none";
      document.getElementById("statsPanel").style.display = "none";
      
      // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
      document.getElementById("autoProcessBtn").disabled = true;
      document.getElementById("manualProcessBtn").disabled = true;
      document.getElementById("resetBtn").disabled = true;
      
      updateStatus("ãƒªã‚»ãƒƒãƒˆå®Œäº†ã€‚æ–°ã—ã„ç”»åƒã‚’é¸æŠã—ã¦ãã ã•ã„", "ready");
    }
  </script>
</body>
</html>
